DROP TABLE IF EXISTS t;

CREATE TABLE t (
    c1 int,
    c2 int,
    c3 int,
    PRIMARY KEY (c1)
);

INSERT INTO t VALUES (1,2,3);

SELECT * from t;
SELECT c1, c2, c3 from t;
SELECT c1, c1 from t;
SELECT c1 as a, c2 as a from t;

SELECT 1;
SELECT 1, 1;
SET @@autocommit = 1;
SELECT @@autocommit;
SELECT @@autocommit, @@autocommit;
SET @a = 10;
SET @b = 11;
SELECT @a, @@autocommit;
SELECT @a, @b;
SELECT 1, @a;
SELECT 1, @a as a;
SELECT 1, @a, @@autocommit as a, c1 from t;
SET @b = "123";
SELECT @b + "123";
# TODO: the field name for 1 + 1 should be "1 + 1", but now is 2
# we may discuss whether to support it like in MySQL later. 
SELECT 1 + 1;

SELECT 1 a, 1 as a, 1 + 1 a;
SELECT c1 a, c1 as a from t;

SELECT * from t LIMIT 0,1;
SELECT * from t LIMIT 1;
SELECT * from t LIMIT 1,1;
SELECT * from t LIMIT 1 OFFSET 0;

DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (
    c1 int,
    c2 int,
    PRIMARY KEY (c1)
);

INSERT INTO t2 VALUES (1,2);

SELECT * from t a;
SELECT * from t a, t2 b;
SELECT * from t as a, t2 as b;
SELECT * from t a left join t2 b on a.c1 = b.c1;

--error ER_DUP_FIELDNAME
SELECT * from (SELECT 1, 1) as a;

--error ER_DUP_FIELDNAME
SELECT * from (SELECT * FROM t, t2) as a;

# Select bool field 
DROP TABLE IF EXISTS t;
CREATE TABLE t (c1 INT, c2 INT);
INSERT INTO t VALUES (1, 2), (1, 1), (1, 3);
SELECT c1=c2 FROM t;
SELECT 1=1;

SELECT t.c1 + t.c2 from t limit 1;
SELECT t.c1 from t limit 1;
SELECT t.c1 + c2 from t limit 1;
SELECT c1 + 10 from t limit 1;
SELECT t.c1 + 10 from t limit 1;

# all
SELECT all c1, c2 from t limit 1;

# distinct
SELECT distinct c1, c2 from t limit 1;

# not
SELECT c2 from t where not (c2 > 2);
select c2 from t where not null is null;

# unary field name
select !(1 + 2);

# - + 
select + - 1, --1, +-+-+1, + "123";
select --------------------1, ++++++++++++++++++++1;
select --+(1 + 1), +-+-(1 * 1);

# where static condition
select * from t where null;
select * from t where 1;
select * from t where 0;
select * from t where 0 * 10;
select * from t where null is not null;
select * from t where !1;
select * from t where 1 && 0 || 3 && null;

# cross join
select * from t as a, t2 as b;
select * from t as a cross join t2 as b;
select * from t as a join t2 as b;
select * from t as a join t2 as b on a.c2 = b.c2;

# from clause
select * from (t);
select * from (t as a, t2 as b);
select * from (t as a cross join t2 as b);

# table nil plan
select 1 as a from t;
select count(*), 1 from t;
select *, 1 from t;

# expr test
select 1, count(1), sum(1);